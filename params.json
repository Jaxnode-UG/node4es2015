{"name":"Node 4.X ES2015 Features","tagline":"This is a repo for the examples from November's JaxNode presentation","body":"# Repo for the November JaxNode meetup examples.\r\n\r\nThis repo contains the examples from the JaxNode November 2015 presentation.\r\n\r\n\r\n## Classes\r\n\r\nOne of the more distinctive features added to ES2015 is the use of the class keyword. \r\nIn ES5 if you wanted to implement class style functions the syntax was rather terse. \r\nIn the example below you can see an example of a class inheriting from another class\r\nusing the old syntax;\r\n\r\n```javascript\r\n\"use strict\";\r\nvar __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar MeetupGroup = (function () {\r\n    function MeetupGroup(name) {\r\n        this.name = name;\r\n    }\r\n    MeetupGroup.prototype.Say = function () {\r\n        console.log(\"This the \" + this.name + \" meetup group!\");\r\n    };\r\n    return MeetupGroup;\r\n})();\r\nvar JavaScriptGroup = (function (_super) {\r\n    __extends(JavaScriptGroup, _super);\r\n    function JavaScriptGroup() {\r\n        _super.apply(this, arguments);\r\n    }\r\n    JavaScriptGroup.prototype.Say = function () {\r\n        _super.prototype.Say.call(this);\r\n        console.log('And is a JavaScript User Group.');\r\n    };\r\n    return JavaScriptGroup;\r\n})(MeetupGroup);\r\nvar meetup = new MeetupGroup('JaxNode');\r\nmeetup.Say();\r\n```  \r\n\r\nNow with the new `class` keyword, the syntax is more concise and \r\neasier to read.\r\n\r\n```javascript\r\n\"use strict\";\r\n\r\nclass MeetupGroup {\r\n\tconstructor(name) {\r\n\t\tthis.name = name;\r\n\t}\r\n\t\r\n\tSay() {\r\n\t\t// Notice use of string templates.\r\n\t\tconsole.log(`This the ${this.name} meetup group!`);\r\n\t}\r\n}\r\n\r\nclass JavaScriptGroup extends MeetupGroup {\r\n\tSay() {\r\n\t\tsuper.Say()\r\n\t\tconsole.log('And is a JavaScript User Group.');\r\n\t}\r\n}\r\n\r\nlet meetup = new MeetupGroup('JaxNode');\r\n\r\nmeetup.Say();\r\n```\r\n\r\n## For-Of\r\n\r\nES2015 also adds a new way way of iterating over collections, arrays etc.\r\nYou can now use the `of` keyword in your for loops. Previously\r\nFor-In would ieterate over the index value and not the item. \r\nThere is also a _feature_ that would include properties\r\nalong with the index.\r\n\r\n```javascript\r\n\"use strict\";\r\n\r\nlet arr = [3, 5, 7];\r\narr.foo = \"hello\";\r\n\r\nfor (let i in arr) {\r\n   console.log(i); // logs \"0\", \"1\", \"2\", \"foo\"\r\n}\r\n```  \r\n\r\nNow with the For-Of syntax, this works a lot more like the C#\r\nforeach.\r\n\r\n```javascript\r\n\"use strict\";\r\n\r\nlet arr = [3, 5, 7];\r\narr.foo = \"hello\";\r\n\r\nfor (let i of arr) {\r\n   console.log(i); // logs \"3\", \"5\", \"7\"\r\n}\r\n```\r\n## Const\r\n\r\nThe `const` keyword now gives us the ability to make a variable\r\nimmutable or readonly. This is a feature that is very popular in \r\nfunctional languages like F#.\r\n\r\n```javascript\r\n\"use strict\";\r\n\r\nconst bar = 'Immutable';\r\nconsole.log(bar);\r\nbar = 'mutable'; // will throw error with --use-strict\r\nconsole.log(bar);\r\n```\r\n\r\n## Let\r\n\r\nThe `let` keyword is another way of declaring variables, \r\nbut with the advantage of restricting the variable to the\r\nscope of the code block. With the `var` keyword, the \r\nvariable always gets hoisted to the top of its scope.\r\n\r\n```javascript\r\nfunction varTest() {\r\n  var x = 31;\r\n  if (true) {\r\n    var x = 71;  // same variable!\r\n    console.log(x);  // 71\r\n  }\r\n  console.log(x);  // 71\r\n}\r\n``` \r\n\r\nIf you use `let` instead of `var`, the variable value will\r\nwork in it's code block.\r\n\r\n```javascript\r\nfunction varTest() {\r\n  var x = 31;\r\n  if (true) {\r\n    var x = 71;  // same variable!\r\n    console.log(x);  // 71\r\n  }\r\n  console.log(x);  // 31\r\n}\r\n``` \r\n\r\n## Sets and WeakSets\r\n\r\nSets are basically just collections. This object\r\ncomes with built in functions for adding, checking\r\nand deleting values from that collection. WeakSets are version of sets, but for objects with \r\nbetter garbage collection.   \r\n\r\n```javascript\r\nvar mySet = new Set([34, 22, 79]);\r\n```\r\nYou can add a value to your set by using the `add()` function.\r\n\r\n```javascript\r\nmySet.add(99);\r\n```\r\n\r\nIf you want to verify that a `Set` has a value, \r\nyou can use the `has()` function.\r\n\r\n```javascript\r\nmySet.has(99); // returns true\r\n```\r\nYou can also delete a value from your `Set` by using the \r\n`delete` function.\r\n\r\n```javascript\r\nmySet.delete(99);\r\nmySet.has(99); // returns false\r\n```\r\n\r\n## Maps and WeakMaps\r\n\r\nMaps are essentially the same as HashMaps in Java \r\nor Dictionaries in C#. It allows you to store collections\r\nof key/value pairs. This object also comes with built in \r\nfunctions for adding, checking, getting and deleting key/value pairs.\r\n\r\n```javascript\r\nvar myMap = new Map([[ 'John', 34], ['Bill', 22], ['Burt', 79]);\r\n```\r\nYou can add key value to a map by using the `set()` function.\r\n\r\n```javascript\r\nmyMap.set('Sarah', 29);\r\n```\r\n\r\nYou can also verify if there is a key value pair in your map\r\nby calling the `has(key)` function.\r\n\r\n```javascript\r\nmyMap.has('Sarah');\r\n```\r\n\r\nYou can return the value for a given key by using \r\nthe `get(key)` function.\r\n\r\n```javascript\r\nmyMap.get('Sarah'); // returns 29;\r\n```\r\n\r\n## Generators \r\n\r\nGenerator objects are returned by generator functions, \r\nand conform to both iterator and the iterable interface.\r\nYou will recognize generator functions by the asterisk (*)\r\nthat follows the `function *` keyword. These functions\r\nuse the `yield` keyword to return an iteration\r\nof the function rather than closing the function.\r\n\r\nOnce you create a generator object by calling\r\nthe generator function, you can use the `next()` function\r\nto return an iteration from the object. That method\r\nreturns a tuple that includes the value and a `done` boolean\r\nvalue to know when the generator is done. \r\n\r\n```javascript\r\n\"use strict\";\r\n\r\nfunction *getSomeValues() {\r\n\tyield 1;\r\n\tyield 2;\r\n\tyield 3;\r\n\tyield 4;\r\n\tyield 5;\r\n}\r\n\r\nvar someValues = getSomeValues();\r\n\r\nconsole.log(someValues.next()); // yields { value: 1, done: false } \r\nconsole.log(someValues.next()); // yields { value: 2, done: false }\r\nconsole.log(someValues.next()); // yields { value: 3, done: false }\r\nconsole.log(someValues.next()); // yields { value: 4, done: false }\r\nconsole.log(someValues.next()); // yields { value: 5, done: false }\r\nconsole.log(someValues.next()); // yields { value: undefined, done: true }\r\n```\r\n\r\n\r\n## Promises\r\n\r\nPromises provide a cleaner way of handling asynchronous \r\nfunctionality in Javascript. When you create a Promise\r\nobject, it uses standard methods for handling return \r\nvalues along with errors and exceptions.\r\n\r\nYou will probably recogize a promise object because several APIs\r\ncurrently use this convention by using `then()` or `success()`\r\nfor handling results returned from an asynchronous operation.\r\n\r\nExceptions use the `catch()` functions to handle errors \r\nthat might occur in your promise.\r\n\r\nYou can declare a promise by passing an executor function\r\nor a closure with `resolve()` and `reject()` functions. \r\n\r\n```javascript\r\nvar p = new Promise(function(resolve, reject) { ... });\r\n```\r\nThis will provide us a nice cleaner syntax for executing\r\nasynchronous behavior.\r\n\r\n```javascript\r\npromise\r\n   .then(function(results) { ... })\r\n   .then(function(results) { ... })\r\n   .then(function(results) { ... })\r\n   .catch(function(err) { ... });\r\n```\r\n\r\nHere is an example of a file system operation using standard callbacks\r\n\r\n```javascript\r\n\"use strict\";\r\n\r\nvar fs = require('fs'),\r\n\trootPath = 'C:\\\\Users\\\\dfekke\\\\Documents\\\\',\r\n\text = 'tiff',\r\n\tnewExt = 'TIF';\r\n\r\nfs.readdir(rootPath, \r\n\tfunction(err, files) {\r\n\t\tif (err) {\r\n\t\t\tconsole.error(\"unable to read directory\");\r\n\t\t} else {\r\n\t\t\tvar re = new RegExp(\"^.*\\\\.\" + ext + \"$\");\r\n\t\t\tfor (var file in files) {\r\n\t\t\t\tif (re.test(files[file])) {\r\n\t\t\t\t\tconsole.log(files[file]);\r\n\t\t\t\t\tvar oldPath = rootPath + files[file];\r\n\t\t\t\t\tvar newPath = rootPath + files[file].substring(0, files[file].length - ext.length) + newExt;\r\n\t\t\t\t\tconsole.log(newPath);\r\n\t\t\t\t\tfs.rename(oldPath, \r\n\t\t\t\t\t\t\t\tnewPath, \r\n\t\t\t\t\t\t\t\tfunction (err) {\r\n\t\t\t\t\t\t\t\t\tconsole.error(\"unable to rename file\");\r\n\t\t\t\t\t});\t\r\n\t\t\t\t}\r\n\t\t\t}\t\r\n\t\t}\r\n});\r\n```\r\n\r\nNow here is an example of the same functionality using Promises\r\nwith the [Bluebird](http://bluebirdjs.com/) npm module.\r\n\r\n```javascript\r\n\"use strict\";\r\n\r\nvar fs = require('fs'),\r\n\tPromise = require(\"bluebird\"),\r\n\trootPath = 'C:\\\\Users\\\\dfekke\\\\Documents\\\\',\r\n\text = 'tiff',\r\n\tnewExt = 'TIF';\r\n\r\nPromise.promisifyAll(fs);\r\n\r\nfs.readdirAsync(rootPath).then((files) => {\r\n\tvar re = new RegExp(\"^.*\\\\.\" + ext + \"$\");\r\n\tfiles.forEach(file => {\r\n\t\tif (re.test(file)) {\r\n\t\t\tconsole.log(file);\r\n\t\t\tvar oldPath = rootPath + file;\r\n\t\t\tvar newPath = rootPath + file.substring(0, file.length - ext.length) + newExt;\r\n\t\t\tconsole.log(newPath);\r\n\t\t\tfs.renameAsync(oldPath, newPath)\r\n\t\t\t\t.catch(err => console.error(\"unable to rename file\") );\r\n\t\t}\r\n\t});\r\n}).catch((err) => console.error(\"unable to read directory\"));\r\n```\r\n\r\n## Lexical scoping for `this` variable\r\n\r\nIt is very common when inner functions are used in \r\nfunction objects to see new variables declared to pass the\r\n`this` variable because of the way javascript scopes the \r\n`this` variable.\r\n\r\n```javascript\r\nvar that = this;\r\n```\r\nNow with ES2015 the `this` variable can be retained if \r\nyou use arrow functions `=>`. This also provides a \r\nnice shorthand when you need to specify closure or\r\ninner functions.\r\n\r\n```javascript\r\nvar bob = {\r\n  _name: \"Bob\",\r\n  _friends: ['Tommy', 'Richard', 'Susan'],\r\n  printFriends() {\r\n\t// Here there is no need to hoist the this object because it can be scoped in the lambda.\r\n    this._friends.forEach(f =>\r\n      console.log(`${this._name}  knows  ${f}`));\r\n  }\r\n};\r\n\r\nbob.printFriends();\r\n``` \r\n\r\n## ...Spread operator (available in Node 5.0)\r\n\r\nThe spread operator denoted by three periods at the \r\nbeginning of a array (`...arr`) provides a nice shorthand \r\nfor concatinating arrays together in ES2015. Unfortunately \r\nthis feature did not get put into the language until \r\nversion 4.6 of V8, so we will not see it without \r\nusing Node 5.0 or later.\r\n\r\n```javascript\r\nlet inner = [3, 4];\r\nlet merged = [0, 1, 2, ...inner, 5]; \r\n```\r\n \r\n\r\nCopyright 2015 JaxNode","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}